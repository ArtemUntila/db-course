# Кэширование

## Цели работы
Знакомство с алгоритмами кэширования. В рамках данной работы необходимо разработать кэширующий SQL-proxy-программу, 
которая принимала бы запросы к БД, отправляла эти запросы в БД, сохраняла бы результаты в хранилище. 
Если приходит повторный запрос на чтение - выдавала запросы из хранилища, если приходит запрос на изменение - сбрасывала
бы значения всех запросов, результаты которых станут неактуальными после внесенных изменений.

## Программа работы
1. Общее описание:
   * для данной работы необходимо выбрать часть таблиц БД (3+), для которой можно придумать/использовать осмысленные 
   SQL-запросы, необходимые для выполнения пользовательских функций
   * в рамках работы необходимо реализовать две программы: кэширующий прокси и программа для выполнения запросов и 
   измерения результатов


2. Выбор понравившегося способа кэширования:
   * в памяти программы
   * с использованием внешних хранилищ
   * во внешней памяти


3. Реализация выбранного способа
   * преобразование входных запросов
   * выбор ключа для хранения результатов
   * реализация алгоритма поиска сохраненных результатов, которые надо сбросить после внесения изменений в БД


4. Снятие показательных характеристик
   * в программе для формирования потока запросов к БД на чтение/изменение/удаление должна быть возможность настройки 
   соотношения запросов, количества запросов разных типов в потоке и измерения временных характеристик: 
   среднее/минимальное/максимальное время выполнения запроса по типу, необходимо иметь возможность проанализировать 
   эффективность кэширования в различных сценариев: преимущественно чтение, преимущественно изменение, преимущественно удаление
   * измерения можно производить путем простого сравнения отметок текущего времени до и после выполнения запросов


5. Анализ полученных результатов и сравнение реализаций с кэшем и без между собой.


6. Демонстрация результатов преподавателю.


## Ход работы


### Способ кэширования
Тип хранения &mdash; в памяти программы.

Алгоритм кэширования &mdash; LRU (https://ru.bmstu.wiki/LRU_(Least_Recently_Used)).


### Реализация
Язык программирования &mdash; `Java`. Драйвер `jdbc` подключен через зависимости [maven](pom.xml).

Директория с исходным кодом: [src/main/java](src/main/java)


#### Запуск
[Main](src/main/java/Main.java)

Программа принимает на вход 4 параметра (целочисленных):
```
<num> <select> <change> <delete>
```

* `<num>` &mdash; общее число запросов
* `<select>` &mdash; доля запросов на чтение
* `<change>` &mdash; доля запросов на изменение
* `<delete>` &mdash; доля запросов на удаление


#### Соединение с БД
[db](src/main/java/db)

Для соединения с БД используется та же логика, что и в ЛР 2. Основным классом, реализующим установку соединения и 
непосредственную отправку запросов к БД, является [Connector](src/main/java/db/Connector.java).

Не включенный в Git класс LocalConnector — наследник Connector для локальной БД, который переопределяет конструктор,
указывая URL локальной БД, имя пользователя и пароль:
```java
public class LocalConnector extends Connector {
    public LocalConnector() {
        super("jdbc:postgresql://localhost/db", "user", "password");
    }
}
```


#### Кэш
[cache](src/main/java/cache)

Кэш реализован в виде структуры данных, хранящей пары `<Ключ, Значение>`. Кэш реализует алгоритм LRU. В программе используются
пары `<String, ResultSet>`, где `String` &mdash; строковое представление ключа, формируемого следующим образом:
```<имя таблицы>_<хэш-код запроса на чтение>```, а `ResultSet` &mdash; класс из библиотеки `java.sql`, представляющий
результат запроса. Формат ключа позволяет легко удалять записи из кэша: при поступлении запроса на изменение/удаление 
из кэша удаляются все пары, ключ которых содержит имя таблицы, к которой относится запрос.


#### Запросы
[query](src/main/java/query)

Для упрощения анализа запросов используется "класс-обёртка" [Query](src/main/java/query/Queries.java), содержащий тип
запроса ([QueryType](src/main/java/query/QueryType.java): чтение/изменение/удаление), имя таблицы, к которой относится
запрос, и непосредственно текст запроса. Также в пакете содержится класс [Queries](src/main/java/query/Queries.java), 
хранящий наборы запросов каждого типа и позволяющий сгенерировать случайный запрос определённого типа. К запросам на 
чтение относён `SELECT`, на изменение &mdash; `UPDATE` и `INSERT`, на удаление &mdash; `DELETE`.


#### Обработка запросов
[query.executor](src/main/java/query/executor)

Данный пакет содержит классы, представляющий наибольший интерес в данной ЛР:
* [DefaultQueryExecutor](src/main/java/query/executor/DefaultQueryExecutor.java) &mdash; не кэширующий обработчик запросов: 
при поступлении запроса на чтение/изменение/удаление просто исполняет его
* [CachedQueryExecutor](src/main/java/query/executor/CachedQueryExecutor.java) &mdash; кэширующий обработчик запросов: 
при поступлении запроса на чтение анализирует содержимое кэша: берёт результат запроса из кэша или выполняет запрос и 
помещает результат в кэш; при поступлении запроса на изменение/удаление удаляет из кэша записи, относящиеся к той же 
таблице, что и запрос, и исполняет его

Для анализа типа и таблицы запроса как раз используются возможности класса-обёртки [Query](src/main/java/query/Queries.java),
описанного в предыдущем пункте.


#### Вспомогательные утилиты
[util](src/main/java/util):
* [Counter](src/main/java/util/Counter.java) &mdash; счётчик-сборщик статистики о среднем/минимальном/максимальном
времени исполнения запросов каждого типа (чтение/изменение/запись)
* [Measurer](src/main/java/util/Measurable.java) &mdash; замер времени исполнения функции в **микросекундах**
* [Params](src/main/java/util/Params.java) &mdash; обёртка для параметров программы


#### Выполнения запросов и измерение результатов
[Executor](src/main/java/Executor.java)

Передаются параметры программы и используемый обработчик запросов. Чтобы исследование "имело смысл" запросы разных типов
должны быть выполнены в случайной последовательности: вероятность запроса каждого типа рассчитывается на основе соотношения
&mdash; долей запросов каждого типа, передаваемых в качестве трёх из четырёх параметров программы. Четвёртый параметр 
(первый по порядку) &mdash; общее число запросов, т. е. сколько раз нужно сгенерировать и выполнить запрос случайного 
(с заданной вероятностью) типа.

После выполнения указанного числа запросов в стандартный поток вывода выводится имя обработчика и статистика времени
исполнения запросов каждого типа в виде:
```
Имя обработчика
Тип запроса (число выполненных запросов):
	Среднее время исполнения
	Минимальное время исполнения
	Максимальное время исполнения
```


### Результаты

Программа запущена три раза для 10000 запросов с соотношениями чтение/изменение/удаление: 8/1/1, 1/8/1, 1/1/8. 
Соответствующие аргументы программы: `10000 8 1 1`, `10000 1 8 1`, `10000 1 1 8`.

Среднее/минимальное/максимальное время исполнения представлено в **микросекундах**.

`10000 8 1 1`:
```
query.executor.DefaultQueryExecutor
SELECT (8015):
	AVG = 99992
	MIN = 1815
	MAX = 1253985

CHANGE (1019):
	AVG = 2147
	MIN = 377
	MAX = 519610

DELETE (966):
	AVG = 201019
	MIN = 6905
	MAX = 2708407

query.executor.CachedQueryExecutor
SELECT (7999):
	AVG = 32267
	MIN = 0
	MAX = 1167413

CHANGE (1060):
	AVG = 1536
	MIN = 365
	MAX = 422855

DELETE (941):
	AVG = 165437
	MIN = 6618
	MAX = 1941611
```

`10000 1 8 1`:
```
query.executor.DefaultQueryExecutor
SELECT (1037):
	AVG = 88190
	MIN = 1892
	MAX = 567592

CHANGE (7977):
	AVG = 1062
	MIN = 357
	MAX = 81160

DELETE (986):
	AVG = 23952
	MIN = 6518
	MAX = 802893

query.executor.CachedQueryExecutor
SELECT (999):
	AVG = 89309
	MIN = 16
	MAX = 819275

CHANGE (7998):
	AVG = 1160
	MIN = 371
	MAX = 540055

DELETE (1003):
	AVG = 23359
	MIN = 6619
	MAX = 54095
```

`10000 1 1 8`:
```
query.executor.DefaultQueryExecutor
SELECT (940):
	AVG = 89781
	MIN = 1630
	MAX = 527035

CHANGE (1007):
	AVG = 836
	MIN = 450
	MAX = 17151

DELETE (8053):
	AVG = 296321
	MIN = 5795
	MAX = 2614490

query.executor.CachedQueryExecutor
SELECT (989):
	AVG = 77924
	MIN = 3
	MAX = 522959

CHANGE (1014):
	AVG = 817
	MIN = 427
	MAX = 16037

DELETE (7997):
	AVG = 241026
	MIN = 4779
	MAX = 2053856
```

По результатам видно, что кэширующий обработчик имеет явный выигрыш по времени исполнения запросов на чтение при их
большом количестве (для соотношения 8/1/1): среднее время исполнения запроса на чтение у кэширующего обработчика
приблизительно в 3 раза меньше, чем у не кэширующего. При уменьшении числа запросов на чтение этот выигрыш становится 
менее заметен: для соотношений 1/8/1 и 1/1/8 оба обработчика имеют приблизительно одинаковое время исполнения 
запросов всех типов.


## Вывод
В ходе лабораторной работы изучен алгоритм кэширования при работе с БД. Разработана кэширующая SQL-Proxy-программа, 
позволяющая не выполнять повторно запросы на чтение, результаты которых остались неизменными после предыдущего идентичного 
запроса. Для сравнения проанализирована обычная программа, отправляющая каждый запрос к БД, и кэширующая Proxy-программа. 
Сравнение проводилось для 10000 запросов и оценивалось среднее/минимальное/максимальное время исполнения запросов на 
чтение/изменение/запись для различных соотношений. Получены вполне ожидаемые результаты: при большом числе запросов на 
чтение кэширующая Proxy-программа имеет заметно меньшее среднее время исполнения запросов на чтение 
(в данной реализации &mdash; в 3 раза), при меньшем числе запросов на чтение среднее время исполнения запросов 
каждого типа у обеих программ приблизительно одинаково.
